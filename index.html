<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>9型戀愛人格測驗</title>
  <style>
/* ===============================================================
   1. 使用 Google Font（繁體中文推薦：Noto Sans TC）
   =============================================================== */
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');

/* ===============================================================
   2. 全局設定
   =============================================================== */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
body {
  font-family: 'Noto Sans TC', sans-serif;
  background: linear-gradient(135deg, #f0f4f8 0%, #d9e2ec 100%);
  color: #333;
  padding: 20px;
  line-height: 1.6;
}

/* ===============================================================
   3. 標題樣式
   =============================================================== */
h1 {
  text-align: center;
  font-size: 2rem;
  font-weight: 700;
  margin-bottom: 40px;
  color: #1a202c;
}

/* ===============================================================
   4. 問卷容器：設定最大寬度、置中
   =============================================================== */
#questionsContainer {
  max-width: 800px;
  margin: 0 auto;
}

/* ===============================================================
   5. 單題卡片（Card）樣式
   =============================================================== */
.question {
  background: #ffffff;
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 20px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.05);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  position: relative;
}
.question:hover {
  transform: translateY(-3px);
  box-shadow: 0 8px 16px rgba(0,0,0,0.08);
}
.question strong {
  display: block;
  font-size: 1.1rem;
  margin-bottom: 10px;
  color: #1a202c;
}

/* ===============================================================
   6. Button Group 樣式 (取代原本的 radio 顯示)
   =============================================================== */
.button-group {
  display: flex;
  justify-content: space-between;
  margin-top: 12px;
  gap: 8px;
  flex-wrap: wrap;
}
.likert-btn {
  flex: 1;
  padding: 10px;
  background-color: #e9ecef;
  border: 1px solid #ccc;
  border-radius: 8px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
  user-select: none;
  font-size: 0.95rem;
  color: #434343;
}
.likert-btn:hover {
  background-color: #dee2e6;
}
.likert-btn.selected {
  background-color: #4c6ef5;
  color: #fff;
  font-weight: bold;
  border-color: #3b5bdb;
}

/* ===============================================================
   7. 提交按鈕樣式
   =============================================================== */
button {
  display: block;
  margin: 30px auto;
  padding: 12px 32px;
  font-size: 1rem;
  font-weight: 600;
  border: none;
  border-radius: 30px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(118, 75, 162, 0.3);
  transition: background 0.3s ease, transform 0.2s ease;
}
button:hover {
  background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
  transform: translateY(-2px);
}

/* ===============================================================
   8. 結果區塊樣式
   =============================================================== */
#result {
  max-width: 800px;
  margin: 40px auto 0;
}
.result-block {
  background: #ffffff;
  border-radius: 12px;
  padding: 25px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.05);
}
.result-block strong {
  display: block;
  font-size: 1.2rem;
  margin-bottom: 15px;
  color: #1a202c;
}
.result-block ol {
  padding-left: 20px;
}
.result-block li {
  margin-bottom: 15px;
}
.personality-title {
  font-size: 1.05rem;
  font-weight: 700;
  color: #4c51bf;
}
.personality-desc {
  font-size: 0.95rem;
  color: #555;
  margin-left: 20px;
  margin-top: 4px;
}

/* ===============================================================
   9. 手機響應式 (小螢幕) 調整
   =============================================================== */
@media (max-width: 600px) {
  body {
    padding: 10px;
  }
  h1 {
    font-size: 1.6rem;
    margin-bottom: 25px;
  }
  .question {
    padding: 15px;
  }
  .question strong {
    font-size: 1rem;
  }
  .likert-btn {
    flex: 1 1 45%;
    padding: 8px;
    font-size: 0.9rem;
  }
  button {
    padding: 10px 24px;
    font-size: 0.95rem;
  }
  .result-block {
    padding: 20px;
  }
  .personality-title {
    font-size: 1rem;
  }
  .personality-desc {
    font-size: 0.9rem;
  }
}
  </style>
</head>
<body onload="renderQuestions()">
  <h1>九大戀愛人格類型測驗</h1>

  <p style="max-width: 800px; margin: 0 auto 30px; line-height: 1.8; font-size: 1rem; text-align: justify;">
    這份簡易的自我診斷問答主要是為了瞭解你的人格類型。<br/>
    請針對每個問題在「非常符合」「符合」「不清楚」「不符合」之中擇一作答。<br/>
    不僅只考慮你現在的感覺或行為，也請回顧過去幾年內你擁有什麼樣的感受？是如何行動的？進而選出最貼切的答案。
  </p>

  <form id="quizForm">
    <div id="questionsContainer">
      <!-- 這裡由 JavaScript 動態填入 90 個問題 -->
    </div>

    <button type="button" onclick="calculateScore()">提交</button>
  </form>

  <div id="result"></div>

  <script>
    // ─── 1. 問題陣列 (90題) ─────────────────────────────────────────
    const questions = [
      // 逃避型（Avoidant）
      "因為討厭被拒絕、被貶低，所以不想從事須要與許多人往來的工作。",
      "不想要那些對自己沒有好感的人扯上關係。",
      "因為不能被討厭，所以即使很親近的人也會壓抑自己去配合他。",
      "總是擔心自己會不會被嘲笑、會不會被排擠。",
      "約好要出門與人碰面，但常常事到臨頭才取消。",
      "覺得反正自己沒有魅力，不太受人喜歡。",
      "想要做些新嘗試時，總會擔心不成功，常常在還沒做之前就先放棄。",
      "不太喜歡穿泳衣或是與對方有身體上的接觸。",
      "很不喜歡與人面對面說話。",
      "覺得要表現自己的心情或感覺是很可恥的事，所以很不擅長。",

      // 依賴型（Dependent）
      "連一點點小事，也不能自己一個人決定。",
      "重要的事或麻煩的事大多都請人幫忙做。",
      "人家一拜託，就無法說 No，最後都會答應。",
      "與其自己去計劃率先去做，還不如跟在別人後面走比較符合自己個性。",
      "為了讓對方覺得自己好，會去做一些其實不想做的事。",
      "沒有自信靠自己一個人活下去。",
      "要是跟戀人或是朋友分手，就會馬上去找下一個人來代替。",
      "對誰都表現得很和氣，外表看起來優點很多。",
      "就算知道這樣不好，但要是覺得對方可憐，就會忍不住寵愛他。",
      "喜歡服務別人，讓別人開心。",
    ];

    // ─── 2. 四個選項分數 (非常符合=2、符合=1、不清楚&不符合=0) ───
    const optionLabels = ["非常符合", "符合", "不清楚", "不符合"];
    const optionValues = [2, 1, 0, 0];

    // ─── 3. 對應「區塊→人格類型名稱→簡介」 ────────────────────────────
    const personalityMap = [
      { name: "逃避型",    desc: "反正自己就不可能得到幸福" },
      { name: "依賴型",    desc: "遷就對方、奉獻自己的一切" },
      { name: "強迫型",    desc: "被義務與責任感束縛" },
      { name: "自戀型",    desc: "如果自己不是主角就毫無意義" },
      { name: "反社會型",  desc: "在危險中追求戰慄感的冒險家" },
      { name: "邊緣型",    desc: "怕被遺棄，感覺不到確實的愛" },
      { name: "演技型",    desc: "運用魔性的魅力達到目的" },
      { name: "亞斯伯格型", desc: "只熱衷於自己的世界" },
      { name: "妄想型",    desc: "打從心底就不相信別人" }
    ];

    // ─── 用來儲存每題答案的陣列（index = 題號），初始為 null ───
    const selectedAnswers = Array(questions.length).fill(null);
    // 表示使用者是否至少按過一次提交（calculateScore）：
    let submissionAttempted = false;
    function renderQuestions() {
      const container = document.getElementById("questionsContainer");
      container.innerHTML = "";  // 先清空

      questions.forEach((q, i) => {
        // 1) 給每題 div 加上 id="question-i"
        const div = document.createElement("div");
        div.className = "question";
        div.id = `question-${i}`; 

        // 2) 按鈕 HTML（四個選項）
        const buttonsHTML = optionLabels.map((label, idx) => `
          <div class="likert-btn"
               data-question="${i}"
               data-value="${optionValues[idx]}"
               onclick="selectOption(${i}, ${idx})">
            ${label}
          </div>
        `).join("");

        div.innerHTML = `
          <strong>Q${i + 1}：</strong> ${q}
          <div class="button-group" id="group-${i}">
            ${buttonsHTML}
          </div>
          <input type="hidden" name="q${i}" id="q${i}" value="" />
        `;
        container.appendChild(div);
      });
    }

    function selectOption(qIdx, optIdx) {
      const group = document.getElementById(`group-${qIdx}`);
      const buttons = group.querySelectorAll(".likert-btn");

      // 移除其他按鈕的 .selected
      buttons.forEach(btn => btn.classList.remove("selected"));

      // 讓被點擊的按鈕加上 .selected
      const chosenBtn = buttons[optIdx];
      chosenBtn.classList.add("selected");

      // 將分數存到 selectedAnswers，存到隱藏 input
      const score = parseInt(chosenBtn.dataset.value, 10);
      selectedAnswers[qIdx] = score;
      document.getElementById(`q${qIdx}`).value = score;

      // ─── 只有當已經按過提交（submissionAttempted === true）才執行「自動找下一個未回答並捲動」 ───
      if (submissionAttempted) {
        let nextUnanswered = -1;
        for (let i = qIdx + 1; i < questions.length; i++) {
          if (selectedAnswers[i] === null) {
            nextUnanswered = i;
            break;
          }
        }

        if (nextUnanswered !== -1) {
          // 如果還有未答的，捲動到那一題
          document.getElementById(`question-${nextUnanswered}`).scrollIntoView({
            behavior: "smooth",
            block: "center"
          });
        } else {
          // 如果已經全部答完，捲動到提交按鈕
          const submitBtn = document.querySelector('button[type="button"]');
          submitBtn.scrollIntoView({
            behavior: "smooth",
            block: "center"
          });
        }
      }
    }
    function calculateScore() {
      // 先找出所有還沒填的題目 index
      const unansweredIndices = [];
      for (let i = 0; i < questions.length; i++) {
        if (selectedAnswers[i] === null) {
          unansweredIndices.push(i);
        }
      }

      // 如果有未回答
      if (unansweredIndices.length > 0) {
        // 標示使用者已按過提交
        submissionAttempted = true;

        // 捲到最小 index 的那一題
        const firstUnanswered = unansweredIndices[0];
        document.getElementById(`question-${firstUnanswered}`).scrollIntoView({
          behavior: "smooth",
          block: "center"
        });
        alert(`請先回答第 ${firstUnanswered + 1} 題。`);
        return; // 不繼續計算分數
      }

      // 如果都回答完，才跑原本計分並顯示結果
      // （下面的程式碼保持原樣）
      const scores = new Array(9).fill(0);
      for (let i = 0; i < questions.length; i++) {
        const groupIndex = Math.floor(i / 10);
        scores[groupIndex] += selectedAnswers[i];
      }

      const results = scores.map((score, idx) => ({
        name: personalityMap[idx].name,
        desc: personalityMap[idx].desc,
        score
      }));

      const nonZeroResults = results.filter(r => r.score > 0);
      nonZeroResults.sort((a, b) => b.score - a.score);

      const grouped = {};
      nonZeroResults.forEach(r => {
        if (!grouped[r.score]) grouped[r.score] = [];
        grouped[r.score].push(r);
      });
      const scoreGroups = Object.keys(grouped)
                                .map(s => parseInt(s, 10))
                                .sort((a, b) => b - a);

      const main = grouped[scoreGroups[0]] || [];
      const secondary = scoreGroups.length > 1 ? grouped[scoreGroups[1]] : [];
      const others = scoreGroups.slice(2).flatMap(s => grouped[s]);

      const resultDiv = document.getElementById("result");
      resultDiv.innerHTML = `
        <div class="result-block">
          <strong>主要人格特徵：</strong>
          <ul>
            ${main.map(r => `
              <li>
                <span class="personality-title">${r.name}：${r.score} 分</span>
                <div class="personality-desc">${r.desc}</div>
              </li>
            `).join("")}
          </ul>
        </div>

        ${secondary.length > 0 ? `
        <div class="result-block">
          <strong>輔助人格特徵：</strong>
          <ul>
            ${secondary.map(r => `
              <li>
                <span class="personality-title">${r.name}：${r.score} 分</span>
                <div class="personality-desc">${r.desc}</div>
              </li>
            `).join("")}
          </ul>
        </div>
        ` : ""}

        ${others.length > 0 ? `
        <div class="result-block">
          <strong>其他人格特徵：</strong>
          <ul>
            ${others.map(r => `
              <li>
                <span class="personality-title">${r.name}：${r.score} 分</span>
                <div class="personality-desc">${r.desc}</div>
              </li>
            `).join("")}
          </ul>
        </div>
        ` : ""}

        <div style="max-width: 800px; margin: 30px auto 0; font-size: 0.9rem; color: #666; line-height: 1.6;">
          <strong>參考資料：</strong><br/>
          本測驗靈感與分類架構參考自：<br/>
          《<a href="https://www.eslite.com/product/1001110932578806?srsltid=AfmBOooylC-HUfkcRIFiSq5Rbns5SUs92euCfCvxXgFyLL5_R64RdKFI" 
               target="_blank" 
               style="color:#4c51bf;text-decoration:underline;">
            戀愛這種病：解讀自我與對方的人格，診斷愛情的現在與未來
          </a>》<br/>
          原書名：《なぜいつも似たような人を喜歡的を書かれるのか》<br/>
          作者：岡田尊司　譯者：張婷婷　出版社：時報文化出版企業股份有限公司（2017/04/05）
        </div>
      `;

      // 最後，滾到結果區塊
      resultDiv.scrollIntoView({ behavior: "smooth", block: "start" });
    }
  </script>
</body>
</html>
